const fs = require('fs');
const path = require('path');

/**
 * This script generates a C parser for the Mode model defined in src/app/models/mode.ts.
 *
 * INSTRUCTIONS FOR UPDATING:
 * 1. If src/app/models/mode.ts changes, update the `schema` object below to reflect the new structure.
 * 2. The `schema` object uses a simplified definition format:
 *    - `type`: 'struct' | 'discriminatedUnion'
 *    - `fields`: Object mapping field names to definitions.
 *    - `refine`: C expression string for validation logic (e.g. "out->has_front || out->has_case_comp").
 * 3. Field definitions:
 *    - `type`: 'string' | 'uint32' | 'boolean' | 'array' | [StructName]
 *    - `min`, `max`: Validation constraints.
 *    - `optional`: boolean.
 *    - `default`: Default value.
 * 4. Run `node scripts/generate_c_parser.cjs` to regenerate mode_parser.h and mode_parser.c.
 */

const schema = {
    PatternChange: {
        type: 'struct',
        fields: {
            ms: { type: 'uint32', min: 0 },
            output: { type: 'string', max: 7 } // #RRGGBB or high/low
        }
    },
    SimplePattern: {
        type: 'struct',
        fields: {
            name: { type: 'string', min: 1, max: 31 },
            duration: { type: 'uint32', min: 1 },
            changeAt: { type: 'array', item: 'PatternChange', min: 1, max: 64 }
        }
    },
    EquationSection: {
        type: 'struct',
        fields: {
            equation: { type: 'string', min: 1, max: 63 },
            duration: { type: 'uint32', min: 1 }
        }
    },
    ChannelConfig: {
        type: 'struct',
        fields: {
            sections: { type: 'array', item: 'EquationSection', max: 8 },
            loopAfterDuration: { type: 'boolean', default: true }
        }
    },
    EquationPattern: {
        type: 'struct',
        fields: {
            id: { type: 'string', max: 36, optional: true },
            name: { type: 'string', min: 1, max: 31 },
            duration: { type: 'uint32', min: 0 },
            red: { type: 'ChannelConfig' },
            green: { type: 'ChannelConfig' },
            blue: { type: 'ChannelConfig' }
        },
        refine: "out->red.sections_count > 0 || out->green.sections_count > 0 || out->blue.sections_count > 0"
    },
    ModePattern: {
        type: 'discriminatedUnion',
        discriminator: 'type',
        variants: {
            simple: 'SimplePattern',
            equation: 'EquationPattern'
        }
    },
    ModeComponent: {
        type: 'struct',
        fields: {
            pattern: { type: 'ModePattern' }
        }
    },
    ModeAccelTrigger: {
        type: 'struct',
        fields: {
            threshold: { type: 'uint32', min: 0 },
            front: { type: 'ModeComponent', optional: true },
            case: { type: 'ModeComponent', optional: true }
        },
        refine: "out->has_front || out->has_case_comp"
    },
    ModeAccel: {
        type: 'struct',
        fields: {
            triggers: { type: 'array', item: 'ModeAccelTrigger', min: 1, max: 8 }
        }
    },
    Mode: {
        type: 'struct',
        fields: {
            name: { type: 'string', min: 1, max: 31 },
            front: { type: 'ModeComponent', optional: true },
            case: { type: 'ModeComponent', optional: true },
            accel: { type: 'ModeAccel', optional: true }
        },
        refine: "out->has_front || out->has_case_comp"
    }
};

function generateHeader() {
    let out = `/* Generated by scripts/generate_c_parser.js */
#ifndef MODE_PARSER_H
#define MODE_PARSER_H

#include <stdint.h>
#include <stdbool.h>
#include "lwjson/lwjson.h"

typedef enum {
    PATTERN_TYPE_SIMPLE,
    PATTERN_TYPE_EQUATION
} PatternType;

`;

    // Forward declarations
    for (const name of Object.keys(schema)) {
        out += `typedef struct ${name} ${name};\n`;
    }
    out += '\n';

    for (const [name, def] of Object.entries(schema)) {
        out += `struct ${name} {\n`;
        if (def.type === 'struct') {
            for (const [fieldName, fieldDef] of Object.entries(def.fields)) {
                const cName = fieldName === 'case' ? 'case_comp' : fieldName;
                if (fieldDef.type === 'string') {
                    out += `    char ${cName}[${fieldDef.max + 1}];\n`;
                } else if (fieldDef.type === 'uint32') {
                    out += `    uint32_t ${cName};\n`;
                } else if (fieldDef.type === 'boolean') {
                    out += `    bool ${cName};\n`;
                } else if (fieldDef.type === 'array') {
                    out += `    ${fieldDef.item} ${cName}[${fieldDef.max}];\n`;
                    out += `    uint8_t ${cName}_count;\n`;
                } else {
                    // Struct type
                    out += `    ${fieldDef.type} ${cName};\n`;
                }
                
                if (fieldDef.optional) {
                    out += `    bool has_${cName};\n`;
                }
            }
        } else if (def.type === 'discriminatedUnion') {
            out += `    PatternType type;\n`;
            out += `    union {\n`;
            for (const [key, typeName] of Object.entries(def.variants)) {
                out += `        ${typeName} ${key};\n`;
            }
            out += `    } data;\n`;
        }
        out += `};\n\n`;
    }

    out += `bool parseMode(lwjson_t *lwjson, lwjson_token_t *token, Mode *out);\n`;
    out += `\n#endif // MODE_PARSER_H\n`;
    return out;
}

function generateSource() {
    let out = `/* Generated by scripts/generate_c_parser.js */
#include <string.h>
#include <stdio.h>
#include "mode_parser.h"

// Helper to copy string safely
static void copyString(char *dest, const lwjson_token_t *token, size_t maxLen) {
    size_t len = token->u.str.token_value_len;
    if (len > maxLen) len = maxLen;
    memcpy(dest, token->u.str.token_value, len);
    dest[len] = '\\0';
}

`;

    // Generate parse functions for each type
    // We need to do this in dependency order or just forward declare.
    // Since C requires definition before use (or forward decl), let's forward declare all parse functions.
    
    for (const name of Object.keys(schema)) {
        out += `static bool parse${name}(lwjson_t *lwjson, lwjson_token_t *token, ${name} *out);\n`;
    }
    out += '\n';

    for (const [name, def] of Object.entries(schema)) {
        out += `static bool parse${name}(lwjson_t *lwjson, lwjson_token_t *token, ${name} *out) {\n`;
        out += `    const lwjson_token_t *t;\n`;
        out += `    bool valid = true;\n`;
        
        if (def.type === 'struct') {
            // Initialize optional flags
            for (const [fieldName, fieldDef] of Object.entries(def.fields)) {
                const cName = fieldName === 'case' ? 'case_comp' : fieldName;
                if (fieldDef.optional) {
                    out += `    out->has_${cName} = false;\n`;
                }
                if (fieldDef.type === 'array') {
                    out += `    out->${cName}_count = 0;\n`;
                }
            }

            for (const [fieldName, fieldDef] of Object.entries(def.fields)) {
                const cName = fieldName === 'case' ? 'case_comp' : fieldName;
                
                out += `    if ((t = lwjson_find_ex(lwjson, token, "${fieldName}")) != NULL) {\n`;
                
                if (fieldDef.type === 'string') {
                    out += `        copyString(out->${cName}, t, ${fieldDef.max});\n`;
                    if (fieldDef.min) {
                        out += `        if (strlen(out->${cName}) < ${fieldDef.min}) valid = false;\n`;
                    }
                } else if (fieldDef.type === 'uint32') {
                    out += `        out->${cName} = (uint32_t)t->u.num_int;\n`;
                    if (fieldDef.min !== undefined) {
                        out += `        if (out->${cName} < ${fieldDef.min}) valid = false;\n`;
                    }
                } else if (fieldDef.type === 'boolean') {
                    out += `        out->${cName} = t->u.num_int != 0; // lwjson parses bools as ints often, or check type\n`;
                    out += `        if (t->type == LWJSON_TYPE_TRUE) out->${cName} = true;\n`;
                    out += `        else if (t->type == LWJSON_TYPE_FALSE) out->${cName} = false;\n`;
                } else if (fieldDef.type === 'array') {
                    out += `        const lwjson_token_t *child = lwjson_get_first_child(t);\n`;
                    out += `        while (child != NULL && out->${cName}_count < ${fieldDef.max}) {\n`;
                    out += `            if (!parse${fieldDef.item}(lwjson, (lwjson_token_t*)child, &out->${cName}[out->${cName}_count])) {\n`;
                    out += `                valid = false;\n`;
                    out += `            }\n`;
                    out += `            out->${cName}_count++;\n`;
                    out += `            child = child->next;\n`;
                    out += `        }\n`;
                    if (fieldDef.min) {
                        out += `        if (out->${cName}_count < ${fieldDef.min}) valid = false;\n`;
                    }
                } else {
                    // Struct type
                    out += `        if (!parse${fieldDef.type}(lwjson, (lwjson_token_t*)t, &out->${cName})) valid = false;\n`;
                }

                if (fieldDef.optional) {
                    out += `        out->has_${cName} = true;\n`;
                }
                
                out += `    }`;
                if (!fieldDef.optional && fieldDef.default === undefined) {
                    out += ` else {\n        valid = false;\n    }\n`;
                } else if (fieldDef.default !== undefined) {
                    out += ` else {\n`;
                    if (fieldDef.type === 'boolean') {
                        out += `        out->${cName} = ${fieldDef.default};\n`;
                    }
                    out += `    }\n`;
                } else {
                    out += `\n`;
                }
            }

            if (def.refine) {
                out += `    if (!(${def.refine})) valid = false;\n`;
            }

        } else if (def.type === 'discriminatedUnion') {
            out += `    if ((t = lwjson_find_ex(lwjson, token, "${def.discriminator}")) != NULL) {\n`;
            out += `        char typeStr[32];\n`;
            out += `        copyString(typeStr, t, 31);\n`;
            
            let first = true;
            for (const [key, typeName] of Object.entries(def.variants)) {
                out += `        ${first ? '' : 'else '}if (strcmp(typeStr, "${key}") == 0) {\n`;
                out += `            out->type = PATTERN_TYPE_${key.toUpperCase()};\n`;
                out += `            if (!parse${typeName}(lwjson, token, &out->data.${key})) valid = false;\n`;
                out += `        }\n`;
                first = false;
            }
            out += `        else { valid = false; }\n`;
            out += `    } else { valid = false; }\n`;
        }

        out += `    return valid;\n`;
        out += `}\n\n`;
    }

    // Expose the main parse function (wrapper to match signature if needed, but here we just use parseMode)
    // The header declares parseMode, which we generated above.

    return out;
}

fs.writeFileSync('mode_parser.h', generateHeader());
fs.writeFileSync('mode_parser.c', generateSource());

console.log('Generated mode_parser.h and mode_parser.c');
