const fs = require('fs');

/**
 * This script generates a C parser for the Mode model defined in src/app/models/mode.ts.
 *
 * INSTRUCTIONS FOR UPDATING:
 * 1. If src/app/models/mode.ts changes, update the `schema` object below to reflect the new structure.
 * 2. The `schema` object uses a simplified definition format:
 *    - `type`: 'struct' | 'discriminatedUnion'
 *    - `fields`: Object mapping field names to definitions.
 *    - `refine`: C expression string for validation logic (e.g. "out->has_front || out->has_case_comp").
 * 3. Field definitions:
 *    - `type`: 'string' | 'uint32' | 'boolean' | 'array' | [StructName]
 *    - `min`, `max`: Validation constraints.
 *    - `optional`: boolean.
 *    - `default`: Default value.
 * 4. Run `node scripts/generate_c_parser.cjs` to regenerate mode_parser.h and mode_parser.c.
 *
 * EXAMPLES:
 *
 * 1. Simple Pattern:
 * {
 *   "name": "Blinky",
 *   "front": {
 *     "pattern": {
 *       "type": "simple",
 *       "name": "Flash",
 *       "duration": 1000,
 *       "changeAt": [
 *         { "ms": 0, "output": "#FF0000" },
 *         { "ms": 500, "output": "#000000" }
 *       ]
 *     }
 *   }
 * }
 *
 * 2. Equation Pattern:
 * {
 *   "name": "Sine Wave",
 *   "case": {
 *     "pattern": {
 *       "type": "equation",
 *       "name": "Red Sine",
 *       "duration": 2000,
 *       "red": {
 *         "sections": [
 *           { "equation": "sin(t * 2 * pi)", "duration": 2000 }
 *         ],
 *         "loopAfterDuration": true
 *       },
 *       "green": { "sections": [] },
 *       "blue": { "sections": [] }
 *     }
 *   }
 * }
 *
 * 3. Accel Trigger:
 * {
 *   "name": "Impact",
 *   "accel": {
 *     "triggers": [
 *       {
 *         "threshold": 2000,
 *         "front": {
 *           "pattern": {
 *             "type": "simple",
 *             "name": "White Flash",
 *             "duration": 100,
 *             "changeAt": [{ "ms": 0, "output": "#FFFFFF" }]
 *           }
 *         }
 *       }
 *     ]
 *   }
 * }
 */

const schema = {
    PatternChange: {
        type: 'struct',
        fields: {
            ms: { type: 'uint32', min: 0 },
            output: { type: 'string', max: 7 } // #RRGGBB or high/low
        },
        refine: { expr: "isValidPatternOutput(out->output)", field: "output" }
    },
    SimplePattern: {
        type: 'struct',
        fields: {
            name: { type: 'string', min: 1, max: 31 },
            duration: { type: 'uint32', min: 1 },
            changeAt: { type: 'array', item: 'PatternChange', min: 1, max: 64 }
        }
    },
    EquationSection: {
        type: 'struct',
        fields: {
            equation: { type: 'string', min: 1, max: 63 },
            duration: { type: 'uint32', min: 1 }
        }
    },
    ChannelConfig: {
        type: 'struct',
        fields: {
            sections: { type: 'array', item: 'EquationSection', max: 8 },
            loopAfterDuration: { type: 'boolean', default: true }
        }
    },
    EquationPattern: {
        type: 'struct',
        fields: {
            name: { type: 'string', min: 1, max: 31 },
            duration: { type: 'uint32', min: 0 },
            red: { type: 'ChannelConfig' },
            green: { type: 'ChannelConfig' },
            blue: { type: 'ChannelConfig' }
        },
        refine: {
            expr: "out->red.sections_count > 0 || out->green.sections_count > 0 || out->blue.sections_count > 0",
            field: "red"
        }
    },
    ModePattern: {
        type: 'discriminatedUnion',
        discriminator: 'type',
        variants: {
            simple: 'SimplePattern',
            equation: 'EquationPattern'
        }
    },
    ModeComponent: {
        type: 'struct',
        fields: {
            pattern: { type: 'ModePattern' }
        }
    },
    ModeAccelTrigger: {
        type: 'struct',
        fields: {
            threshold: { type: 'uint32', min: 0 },
            front: { type: 'ModeComponent', optional: true },
            case: { type: 'ModeComponent', optional: true }
        },
        refine: { expr: "out->has_front || out->has_case_comp", field: "front" }
    },
    ModeAccel: {
        type: 'struct',
        fields: {
            triggers: { type: 'array', item: 'ModeAccelTrigger', min: 1, max: 8 }
        }
    },
    Mode: {
        type: 'struct',
        fields: {
            name: { type: 'string', min: 1, max: 31 },
            front: { type: 'ModeComponent', optional: true },
            case: { type: 'ModeComponent', optional: true },
            accel: { type: 'ModeAccel', optional: true }
        },
        refine: { expr: "out->has_front || out->has_case_comp", field: "front" }
    }
};

function generateHeader() {
    let out = `/* Generated by scripts/generate_c_parser.cjs */
#ifndef MODE_PARSER_H
#define MODE_PARSER_H

#include <stdint.h>
#include <stdbool.h>
#include "lwjson/lwjson.h"

typedef enum {
    MODE_PARSER_OK = 0,
    MODE_PARSER_ERR_MISSING_FIELD,
    MODE_PARSER_ERR_STRING_TOO_SHORT,
    MODE_PARSER_ERR_VALUE_TOO_SMALL,
    MODE_PARSER_ERR_ARRAY_TOO_SHORT,
    MODE_PARSER_ERR_INVALID_VARIANT,
    MODE_PARSER_ERR_VALIDATION_FAILED
} ModeParserError;

typedef struct {
    ModeParserError error;
    char path[128];
} ModeErrorContext;

const char* modeParserErrorToString(ModeParserError err);

typedef enum {
    PATTERN_TYPE_SIMPLE,
    PATTERN_TYPE_EQUATION
} PatternType;

`;

    // Forward declarations
    for (const name of Object.keys(schema)) {
        out += `typedef struct ${name} ${name};\n`;
    }
    out += '\n';

    for (const [name, def] of Object.entries(schema)) {
        out += `struct ${name} {\n`;
        if (def.type === 'struct') {
            for (const [fieldName, fieldDef] of Object.entries(def.fields)) {
                const cName = fieldName === 'case' ? 'case_comp' : fieldName;
                if (fieldDef.type === 'string') {
                    out += `    char ${cName}[${fieldDef.max + 1}];\n`;
                } else if (fieldDef.type === 'uint32') {
                    out += `    uint32_t ${cName};\n`;
                } else if (fieldDef.type === 'boolean') {
                    out += `    bool ${cName};\n`;
                } else if (fieldDef.type === 'array') {
                    out += `    ${fieldDef.item} ${cName}[${fieldDef.max}];\n`;
                    out += `    uint8_t ${cName}_count;\n`;
                } else {
                    // Struct type
                    out += `    ${fieldDef.type} ${cName};\n`;
                }
                
                if (fieldDef.optional) {
                    out += `    bool has_${cName};\n`;
                }
            }
        } else if (def.type === 'discriminatedUnion') {
            out += `    PatternType type;\n`;
            out += `    union {\n`;
            for (const [key, typeName] of Object.entries(def.variants)) {
                out += `        ${typeName} ${key};\n`;
            }
            out += `    } data;\n`;
        }
        out += `};\n\n`;
    }

    out += `ModeParserError parseMode(lwjson_t *lwjson, lwjson_token_t *token, Mode *out, ModeErrorContext *ctx);\n`;
    out += `\n#endif // MODE_PARSER_H\n`;
    return out;
}

function generateSource() {
    let out = `/* Generated by scripts/generate_c_parser.js */
#include <string.h>
#include <stdio.h>
#include "mode_parser.h"

// Helper to copy string safely
static void copyString(char *dest, const lwjson_token_t *token, size_t maxLen) {
    size_t len = token->u.str.token_value_len;
    if (len > maxLen) len = maxLen;
    memcpy(dest, token->u.str.token_value, len);
    dest[len] = '\\0';
}

static void prependContext(ModeErrorContext *ctx, const char *prefix, int32_t index) {
    char tmp[256];
    if (ctx->path[0] == '\\0') {
        if (index >= 0) snprintf(tmp, sizeof(tmp), "%s[%d]", prefix, (int)index);
        else snprintf(tmp, sizeof(tmp), "%s", prefix);
    } else {
        if (index >= 0) snprintf(tmp, sizeof(tmp), "%s[%d].%s", prefix, (int)index, ctx->path);
        else snprintf(tmp, sizeof(tmp), "%s.%s", prefix, ctx->path);
    }
    strncpy(ctx->path, tmp, sizeof(ctx->path) - 1);
    ctx->path[sizeof(ctx->path) - 1] = '\\0';
}

const char* modeParserErrorToString(ModeParserError err) {
    switch (err) {
        case MODE_PARSER_OK: return "Success";
        case MODE_PARSER_ERR_MISSING_FIELD: return "Missing required field";
        case MODE_PARSER_ERR_STRING_TOO_SHORT: return "String is too short";
        case MODE_PARSER_ERR_VALUE_TOO_SMALL: return "Value is too small";
        case MODE_PARSER_ERR_ARRAY_TOO_SHORT: return "Array has too few items";
        case MODE_PARSER_ERR_INVALID_VARIANT: return "Invalid variant type";
        case MODE_PARSER_ERR_VALIDATION_FAILED: return "Validation failed";
        default: return "Unknown error";
    }
}

static bool isValidPatternOutput(const char *s) {
    if (strcmp(s, "high") == 0) return true;
    if (strcmp(s, "low") == 0) return true;
    if (s[0] == '#') {
        if (strlen(s) != 7) return false;
        for (int i = 1; i < 7; i++) {
            char c = s[i];
            if (!((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))) return false;
        }
        return true;
    }
    return false;
}

`;

    // Generate parse functions for each type
    // We need to do this in dependency order or just forward declare.
    // Since C requires definition before use (or forward decl), let's forward declare all parse functions.
    
    for (const name of Object.keys(schema)) {
        if (name === 'Mode') continue;
        out += `static ModeParserError parse${name}(lwjson_t *lwjson, lwjson_token_t *token, ${name} *out, ModeErrorContext *ctx);\n`;
    }
    out += '\n';

    for (const [name, def] of Object.entries(schema)) {
        const prefix = name === 'Mode' ? '' : 'static ';
        out += `${prefix}ModeParserError parse${name}(lwjson_t *lwjson, lwjson_token_t *token, ${name} *out, ModeErrorContext *ctx) {\n`;
        out += `    const lwjson_token_t *t;\n`;
        out += `    ModeParserError err = MODE_PARSER_OK;\n`;
        
        if (def.type === 'struct') {
            // Initialize optional flags
            for (const [fieldName, fieldDef] of Object.entries(def.fields)) {
                const cName = fieldName === 'case' ? 'case_comp' : fieldName;
                if (fieldDef.optional) {
                    out += `    out->has_${cName} = false;\n`;
                }
                if (fieldDef.type === 'array') {
                    out += `    out->${cName}_count = 0;\n`;
                }
            }

            for (const [fieldName, fieldDef] of Object.entries(def.fields)) {
                const cName = fieldName === 'case' ? 'case_comp' : fieldName;
                
                out += `    if ((t = lwjson_find_ex(lwjson, token, "${fieldName}")) != NULL) {\n`;
                
                if (fieldDef.type === 'string') {
                    out += `        copyString(out->${cName}, t, ${fieldDef.max});\n`;
                    if (fieldDef.min) {
                        out += `        if (strlen(out->${cName}) < ${fieldDef.min}) {\n`;
                        out += `            ctx->error = MODE_PARSER_ERR_STRING_TOO_SHORT;\n`;
                        out += `            strcpy(ctx->path, "${fieldName}");\n`;
                        out += `            return ctx->error;\n`;
                        out += `        }\n`;
                    }
                } else if (fieldDef.type === 'uint32') {
                    out += `        out->${cName} = (uint32_t)t->u.num_int;\n`;
                    if (fieldDef.min !== undefined) {
                        out += `        if (out->${cName} < ${fieldDef.min}) {\n`;
                        out += `            ctx->error = MODE_PARSER_ERR_VALUE_TOO_SMALL;\n`;
                        out += `            strcpy(ctx->path, "${fieldName}");\n`;
                        out += `            return ctx->error;\n`;
                        out += `        }\n`;
                    }
                } else if (fieldDef.type === 'boolean') {
                    out += `        out->${cName} = t->u.num_int != 0; // lwjson parses bools as ints often, or check type\n`;
                    out += `        if (t->type == LWJSON_TYPE_TRUE) out->${cName} = true;\n`;
                    out += `        else if (t->type == LWJSON_TYPE_FALSE) out->${cName} = false;\n`;
                } else if (fieldDef.type === 'array') {
                    out += `        const lwjson_token_t *child = lwjson_get_first_child(t);\n`;
                    out += `        while (child != NULL && out->${cName}_count < ${fieldDef.max}) {\n`;
                    out += `            if ((err = parse${fieldDef.item}(lwjson, (lwjson_token_t*)child, &out->${cName}[out->${cName}_count], ctx)) != MODE_PARSER_OK) {\n`;
                    out += `                prependContext(ctx, "${fieldName}", out->${cName}_count);\n`;
                    out += `                return err;\n`;
                    out += `            }\n`;
                    out += `            out->${cName}_count++;\n`;
                    out += `            child = child->next;\n`;
                    out += `        }\n`;
                    if (fieldDef.min) {
                        out += `        if (out->${cName}_count < ${fieldDef.min}) {\n`;
                        out += `            ctx->error = MODE_PARSER_ERR_ARRAY_TOO_SHORT;\n`;
                        out += `            strcpy(ctx->path, "${fieldName}");\n`;
                        out += `            return ctx->error;\n`;
                        out += `        }\n`;
                    }
                } else {
                    // Struct type
                    out += `        if ((err = parse${fieldDef.type}(lwjson, (lwjson_token_t*)t, &out->${cName}, ctx)) != MODE_PARSER_OK) {\n`;
                    out += `            prependContext(ctx, "${fieldName}", -1);\n`;
                    out += `            return err;\n`;
                    out += `        }\n`;
                }

                if (fieldDef.optional) {
                    out += `        out->has_${cName} = true;\n`;
                }
                
                out += `    }`;
                if (!fieldDef.optional && fieldDef.default === undefined) {
                    out += ` else {\n`;
                    out += `        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;\n`;
                    out += `        strcpy(ctx->path, "${fieldName}");\n`;
                    out += `        return ctx->error;\n`;
                    out += `    }\n`;
                } else if (fieldDef.default !== undefined) {
                    out += ` else {\n`;
                    if (fieldDef.type === 'boolean') {
                        out += `        out->${cName} = ${fieldDef.default};\n`;
                    }
                    out += `    }\n`;
                } else {
                    out += `\n`;
                }
            }

            if (def.refine) {
                const refineExpr = typeof def.refine === 'string' ? def.refine : def.refine.expr;
                const refineField = typeof def.refine === 'object' && def.refine.field ? def.refine.field : null;
                
                out += `    if (!(${refineExpr})) {\n`;
                out += `        ctx->error = MODE_PARSER_ERR_VALIDATION_FAILED;\n`;
                if (refineField) {
                    out += `        strcpy(ctx->path, "${refineField}");\n`;
                } else {
                    out += `        ctx->path[0] = '\\0';\n`;
                }
                out += `        return ctx->error;\n`;
                out += `    }\n`;
            }

        } else if (def.type === 'discriminatedUnion') {
            out += `    if ((t = lwjson_find_ex(lwjson, token, "${def.discriminator}")) != NULL) {\n`;
            out += `        char typeStr[32];\n`;
            out += `        copyString(typeStr, t, 31);\n`;
            
            let first = true;
            for (const [key, typeName] of Object.entries(def.variants)) {
                out += `        ${first ? '' : 'else '}if (strcmp(typeStr, "${key}") == 0) {\n`;
                out += `            out->type = PATTERN_TYPE_${key.toUpperCase()};\n`;
                out += `            if ((err = parse${typeName}(lwjson, token, &out->data.${key}, ctx)) != MODE_PARSER_OK) return err;\n`;
                out += `        }\n`;
                first = false;
            }
            out += `        else {\n`;
            out += `            ctx->error = MODE_PARSER_ERR_INVALID_VARIANT;\n`;
            out += `            strcpy(ctx->path, "${def.discriminator}");\n`;
            out += `            return ctx->error;\n`;
            out += `        }\n`;
            out += `    } else {\n`;
            out += `        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;\n`;
            out += `        strcpy(ctx->path, "${def.discriminator}");\n`;
            out += `        return ctx->error;\n`;
            out += `    }\n`;
        }

        out += `    return MODE_PARSER_OK;\n`;
        out += `}\n\n`;
    }

    // Expose the main parse function (wrapper to match signature if needed, but here we just use parseMode)
    // The header declares parseMode, which we generated above.

    return out;
}

fs.writeFileSync('mode_parser.h', generateHeader());
fs.writeFileSync('mode_parser.c', generateSource());

console.log('Generated mode_parser.h and mode_parser.c');
