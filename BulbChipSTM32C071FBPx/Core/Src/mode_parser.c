/* Generated by scripts/generate_c_parser.ts */
#include <string.h>
#include <stdio.h>
#include "mode_parser.h"

// Helper to copy string safely
static void copyString(char *dest, const lwjson_token_t *token, size_t maxLen) {
    size_t len = token->u.str.token_value_len;
    if (len > maxLen) len = maxLen;
    memcpy(dest, token->u.str.token_value, len);
    dest[len] = '\0';
}

static void prependContext(ModeErrorContext *ctx, const char *prefix, int32_t index) {
    char tmp[256];
    if (ctx->path[0] == '\0') {
        if (index >= 0) snprintf(tmp, sizeof(tmp), "%s[%d]", prefix, (int)index);
        else snprintf(tmp, sizeof(tmp), "%s", prefix);
    } else {
        if (index >= 0) snprintf(tmp, sizeof(tmp), "%s[%d].%s", prefix, (int)index, ctx->path);
        else snprintf(tmp, sizeof(tmp), "%s.%s", prefix, ctx->path);
    }
    strncpy(ctx->path, tmp, sizeof(ctx->path) - 1);
    ctx->path[sizeof(ctx->path) - 1] = '\0';
}

const char* modeParserErrorToString(ModeParserError err) {
    switch (err) {
        case MODE_PARSER_OK: return "Success";
        case MODE_PARSER_ERR_MISSING_FIELD: return "Missing required field";
        case MODE_PARSER_ERR_STRING_TOO_SHORT: return "String is too short";
        case MODE_PARSER_ERR_VALUE_TOO_SMALL: return "Value is too small";
        case MODE_PARSER_ERR_ARRAY_TOO_SHORT: return "Array has too few items";
        case MODE_PARSER_ERR_INVALID_VARIANT: return "Invalid variant type";
        case MODE_PARSER_ERR_VALIDATION_FAILED: return "Validation failed";
        default: return "Unknown error";
    }
}

static bool isValidPatternOutput(const char *s) {
    if (strcmp(s, "high") == 0) return true;
    if (strcmp(s, "low") == 0) return true;
    if (s[0] == '#') {
        if (strlen(s) != 7) return false;
        for (int i = 1; i < 7; i++) {
            char c = s[i];
            if (!((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))) return false;
        }
        return true;
    }
    return false;
}

static ModeParserError parsePatternChange(lwjson_t *lwjson, lwjson_token_t *token, PatternChange *out, ModeErrorContext *ctx);
static ModeParserError parseSimplePattern(lwjson_t *lwjson, lwjson_token_t *token, SimplePattern *out, ModeErrorContext *ctx);
static ModeParserError parseEquationSection(lwjson_t *lwjson, lwjson_token_t *token, EquationSection *out, ModeErrorContext *ctx);
static ModeParserError parseChannelConfig(lwjson_t *lwjson, lwjson_token_t *token, ChannelConfig *out, ModeErrorContext *ctx);
static ModeParserError parseEquationPattern(lwjson_t *lwjson, lwjson_token_t *token, EquationPattern *out, ModeErrorContext *ctx);
static ModeParserError parseModePattern(lwjson_t *lwjson, lwjson_token_t *token, ModePattern *out, ModeErrorContext *ctx);
static ModeParserError parseModeComponent(lwjson_t *lwjson, lwjson_token_t *token, ModeComponent *out, ModeErrorContext *ctx);
static ModeParserError parseModeAccelTrigger(lwjson_t *lwjson, lwjson_token_t *token, ModeAccelTrigger *out, ModeErrorContext *ctx);
static ModeParserError parseModeAccel(lwjson_t *lwjson, lwjson_token_t *token, ModeAccel *out, ModeErrorContext *ctx);

static ModeParserError parsePatternChange(lwjson_t *lwjson, lwjson_token_t *token, PatternChange *out, ModeErrorContext *ctx) {
    const lwjson_token_t *t;
    ModeParserError err = MODE_PARSER_OK;
    if ((t = lwjson_find_ex(lwjson, token, "ms")) != NULL) {
        out->ms = (uint32_t)t->u.num_int;
        if (out->ms < 0) {
            ctx->error = MODE_PARSER_ERR_VALUE_TOO_SMALL;
            strcpy(ctx->path, "ms");
            return ctx->error;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "ms");
        return ctx->error;
    }
    if ((t = lwjson_find_ex(lwjson, token, "output")) != NULL) {
        copyString(out->output, t, 7);
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "output");
        return ctx->error;
    }
    if (!(isValidPatternOutput(out->output))) {
        ctx->error = MODE_PARSER_ERR_VALIDATION_FAILED;
        strcpy(ctx->path, "output");
        return ctx->error;
    }
    return MODE_PARSER_OK;
}

static ModeParserError parseSimplePattern(lwjson_t *lwjson, lwjson_token_t *token, SimplePattern *out, ModeErrorContext *ctx) {
    const lwjson_token_t *t;
    ModeParserError err = MODE_PARSER_OK;
    out->changeAt_count = 0;
    if ((t = lwjson_find_ex(lwjson, token, "name")) != NULL) {
        copyString(out->name, t, 31);
        if (strlen(out->name) < 1) {
            ctx->error = MODE_PARSER_ERR_STRING_TOO_SHORT;
            strcpy(ctx->path, "name");
            return ctx->error;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "name");
        return ctx->error;
    }
    if ((t = lwjson_find_ex(lwjson, token, "duration")) != NULL) {
        out->duration = (uint32_t)t->u.num_int;
        if (out->duration < 1) {
            ctx->error = MODE_PARSER_ERR_VALUE_TOO_SMALL;
            strcpy(ctx->path, "duration");
            return ctx->error;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "duration");
        return ctx->error;
    }
    if ((t = lwjson_find_ex(lwjson, token, "changeAt")) != NULL) {
        const lwjson_token_t *child = lwjson_get_first_child(t);
        while (child != NULL && out->changeAt_count < 64) {
            if ((err = parsePatternChange(lwjson, (lwjson_token_t*)child, &out->changeAt[out->changeAt_count], ctx)) != MODE_PARSER_OK) {
                prependContext(ctx, "changeAt", out->changeAt_count);
                return err;
            }
            out->changeAt_count++;
            child = child->next;
        }
        if (out->changeAt_count < 1) {
            ctx->error = MODE_PARSER_ERR_ARRAY_TOO_SHORT;
            strcpy(ctx->path, "changeAt");
            return ctx->error;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "changeAt");
        return ctx->error;
    }
    return MODE_PARSER_OK;
}

static ModeParserError parseEquationSection(lwjson_t *lwjson, lwjson_token_t *token, EquationSection *out, ModeErrorContext *ctx) {
    const lwjson_token_t *t;
    ModeParserError err = MODE_PARSER_OK;
    if ((t = lwjson_find_ex(lwjson, token, "equation")) != NULL) {
        copyString(out->equation, t, 63);
        if (strlen(out->equation) < 1) {
            ctx->error = MODE_PARSER_ERR_STRING_TOO_SHORT;
            strcpy(ctx->path, "equation");
            return ctx->error;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "equation");
        return ctx->error;
    }
    if ((t = lwjson_find_ex(lwjson, token, "duration")) != NULL) {
        out->duration = (uint32_t)t->u.num_int;
        if (out->duration < 1) {
            ctx->error = MODE_PARSER_ERR_VALUE_TOO_SMALL;
            strcpy(ctx->path, "duration");
            return ctx->error;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "duration");
        return ctx->error;
    }
    return MODE_PARSER_OK;
}

static ModeParserError parseChannelConfig(lwjson_t *lwjson, lwjson_token_t *token, ChannelConfig *out, ModeErrorContext *ctx) {
    const lwjson_token_t *t;
    ModeParserError err = MODE_PARSER_OK;
    out->sections_count = 0;
    if ((t = lwjson_find_ex(lwjson, token, "sections")) != NULL) {
        const lwjson_token_t *child = lwjson_get_first_child(t);
        while (child != NULL && out->sections_count < 8) {
            if ((err = parseEquationSection(lwjson, (lwjson_token_t*)child, &out->sections[out->sections_count], ctx)) != MODE_PARSER_OK) {
                prependContext(ctx, "sections", out->sections_count);
                return err;
            }
            out->sections_count++;
            child = child->next;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "sections");
        return ctx->error;
    }
    if ((t = lwjson_find_ex(lwjson, token, "loopAfterDuration")) != NULL) {
        out->loopAfterDuration = t->u.num_int != 0; // lwjson parses bools as ints often, or check type
        if (t->type == LWJSON_TYPE_TRUE) out->loopAfterDuration = true;
        else if (t->type == LWJSON_TYPE_FALSE) out->loopAfterDuration = false;
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "loopAfterDuration");
        return ctx->error;
    }
    return MODE_PARSER_OK;
}

static ModeParserError parseEquationPattern(lwjson_t *lwjson, lwjson_token_t *token, EquationPattern *out, ModeErrorContext *ctx) {
    const lwjson_token_t *t;
    ModeParserError err = MODE_PARSER_OK;
    if ((t = lwjson_find_ex(lwjson, token, "name")) != NULL) {
        copyString(out->name, t, 31);
        if (strlen(out->name) < 1) {
            ctx->error = MODE_PARSER_ERR_STRING_TOO_SHORT;
            strcpy(ctx->path, "name");
            return ctx->error;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "name");
        return ctx->error;
    }
    if ((t = lwjson_find_ex(lwjson, token, "duration")) != NULL) {
        out->duration = (uint32_t)t->u.num_int;
        if (out->duration < 0) {
            ctx->error = MODE_PARSER_ERR_VALUE_TOO_SMALL;
            strcpy(ctx->path, "duration");
            return ctx->error;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "duration");
        return ctx->error;
    }
    if ((t = lwjson_find_ex(lwjson, token, "red")) != NULL) {
        if ((err = parseChannelConfig(lwjson, (lwjson_token_t*)t, &out->red, ctx)) != MODE_PARSER_OK) {
            prependContext(ctx, "red", -1);
            return err;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "red");
        return ctx->error;
    }
    if ((t = lwjson_find_ex(lwjson, token, "green")) != NULL) {
        if ((err = parseChannelConfig(lwjson, (lwjson_token_t*)t, &out->green, ctx)) != MODE_PARSER_OK) {
            prependContext(ctx, "green", -1);
            return err;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "green");
        return ctx->error;
    }
    if ((t = lwjson_find_ex(lwjson, token, "blue")) != NULL) {
        if ((err = parseChannelConfig(lwjson, (lwjson_token_t*)t, &out->blue, ctx)) != MODE_PARSER_OK) {
            prependContext(ctx, "blue", -1);
            return err;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "blue");
        return ctx->error;
    }
    if (!(out->red.sections_count > 0 || out->green.sections_count > 0 || out->blue.sections_count > 0)) {
        ctx->error = MODE_PARSER_ERR_VALIDATION_FAILED;
        strcpy(ctx->path, "red");
        return ctx->error;
    }
    return MODE_PARSER_OK;
}

static ModeParserError parseModePattern(lwjson_t *lwjson, lwjson_token_t *token, ModePattern *out, ModeErrorContext *ctx) {
    const lwjson_token_t *t;
    ModeParserError err = MODE_PARSER_OK;
    if ((t = lwjson_find_ex(lwjson, token, "type")) != NULL) {
        char typeStr[32];
        copyString(typeStr, t, 31);
        if (strcmp(typeStr, "simple") == 0) {
            out->type = PATTERN_TYPE_SIMPLE;
            if ((err = parseSimplePattern(lwjson, token, &out->data.simple, ctx)) != MODE_PARSER_OK) return err;
        }
        else if (strcmp(typeStr, "equation") == 0) {
            out->type = PATTERN_TYPE_EQUATION;
            if ((err = parseEquationPattern(lwjson, token, &out->data.equation, ctx)) != MODE_PARSER_OK) return err;
        }
        else {
            ctx->error = MODE_PARSER_ERR_INVALID_VARIANT;
            strcpy(ctx->path, "type");
            return ctx->error;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "type");
        return ctx->error;
    }
    return MODE_PARSER_OK;
}

static ModeParserError parseModeComponent(lwjson_t *lwjson, lwjson_token_t *token, ModeComponent *out, ModeErrorContext *ctx) {
    const lwjson_token_t *t;
    ModeParserError err = MODE_PARSER_OK;
    if ((t = lwjson_find_ex(lwjson, token, "pattern")) != NULL) {
        if ((err = parseModePattern(lwjson, (lwjson_token_t*)t, &out->pattern, ctx)) != MODE_PARSER_OK) {
            prependContext(ctx, "pattern", -1);
            return err;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "pattern");
        return ctx->error;
    }
    return MODE_PARSER_OK;
}

static ModeParserError parseModeAccelTrigger(lwjson_t *lwjson, lwjson_token_t *token, ModeAccelTrigger *out, ModeErrorContext *ctx) {
    const lwjson_token_t *t;
    ModeParserError err = MODE_PARSER_OK;
    out->has_front = false;
    out->has_case_comp = false;
    if ((t = lwjson_find_ex(lwjson, token, "threshold")) != NULL) {
        out->threshold = (uint32_t)t->u.num_int;
        if (out->threshold < 0) {
            ctx->error = MODE_PARSER_ERR_VALUE_TOO_SMALL;
            strcpy(ctx->path, "threshold");
            return ctx->error;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "threshold");
        return ctx->error;
    }
    if ((t = lwjson_find_ex(lwjson, token, "front")) != NULL) {
        if ((err = parseModeComponent(lwjson, (lwjson_token_t*)t, &out->front, ctx)) != MODE_PARSER_OK) {
            prependContext(ctx, "front", -1);
            return err;
        }
        out->has_front = true;
    }
    if ((t = lwjson_find_ex(lwjson, token, "case")) != NULL) {
        if ((err = parseModeComponent(lwjson, (lwjson_token_t*)t, &out->case_comp, ctx)) != MODE_PARSER_OK) {
            prependContext(ctx, "case", -1);
            return err;
        }
        out->has_case_comp = true;
    }
    if (!(out->has_front || out->has_case_comp)) {
        ctx->error = MODE_PARSER_ERR_VALIDATION_FAILED;
        strcpy(ctx->path, "front");
        return ctx->error;
    }
    return MODE_PARSER_OK;
}

static ModeParserError parseModeAccel(lwjson_t *lwjson, lwjson_token_t *token, ModeAccel *out, ModeErrorContext *ctx) {
    const lwjson_token_t *t;
    ModeParserError err = MODE_PARSER_OK;
    out->triggers_count = 0;
    if ((t = lwjson_find_ex(lwjson, token, "triggers")) != NULL) {
        const lwjson_token_t *child = lwjson_get_first_child(t);
        while (child != NULL && out->triggers_count < 8) {
            if ((err = parseModeAccelTrigger(lwjson, (lwjson_token_t*)child, &out->triggers[out->triggers_count], ctx)) != MODE_PARSER_OK) {
                prependContext(ctx, "triggers", out->triggers_count);
                return err;
            }
            out->triggers_count++;
            child = child->next;
        }
        if (out->triggers_count < 1) {
            ctx->error = MODE_PARSER_ERR_ARRAY_TOO_SHORT;
            strcpy(ctx->path, "triggers");
            return ctx->error;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "triggers");
        return ctx->error;
    }
    return MODE_PARSER_OK;
}

ModeParserError parseMode(lwjson_t *lwjson, lwjson_token_t *token, Mode *out, ModeErrorContext *ctx) {
    const lwjson_token_t *t;
    ModeParserError err = MODE_PARSER_OK;
    out->has_front = false;
    out->has_case_comp = false;
    out->has_accel = false;
    if ((t = lwjson_find_ex(lwjson, token, "name")) != NULL) {
        copyString(out->name, t, 31);
        if (strlen(out->name) < 1) {
            ctx->error = MODE_PARSER_ERR_STRING_TOO_SHORT;
            strcpy(ctx->path, "name");
            return ctx->error;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "name");
        return ctx->error;
    }
    if ((t = lwjson_find_ex(lwjson, token, "front")) != NULL) {
        if ((err = parseModeComponent(lwjson, (lwjson_token_t*)t, &out->front, ctx)) != MODE_PARSER_OK) {
            prependContext(ctx, "front", -1);
            return err;
        }
        out->has_front = true;
    }
    if ((t = lwjson_find_ex(lwjson, token, "case")) != NULL) {
        if ((err = parseModeComponent(lwjson, (lwjson_token_t*)t, &out->case_comp, ctx)) != MODE_PARSER_OK) {
            prependContext(ctx, "case", -1);
            return err;
        }
        out->has_case_comp = true;
    }
    if ((t = lwjson_find_ex(lwjson, token, "accel")) != NULL) {
        if ((err = parseModeAccel(lwjson, (lwjson_token_t*)t, &out->accel, ctx)) != MODE_PARSER_OK) {
            prependContext(ctx, "accel", -1);
            return err;
        }
        out->has_accel = true;
    }
    if (!(out->has_front || out->has_case_comp)) {
        ctx->error = MODE_PARSER_ERR_VALIDATION_FAILED;
        strcpy(ctx->path, "front");
        return ctx->error;
    }
    return MODE_PARSER_OK;
}

