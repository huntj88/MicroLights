/* Generated by scripts/generate_c_parser.js */
#include <string.h>
#include <stdio.h>
#include "mode_parser.h"

// Helper to copy string safely
static void copyString(char *dest, const lwjson_token_t *token, size_t maxLen) {
    size_t len = token->u.str.token_value_len;
    if (len > maxLen) len = maxLen;
    memcpy(dest, token->u.str.token_value, len);
    dest[len] = '\0';
}

static bool parsePatternChange(lwjson_t *lwjson, lwjson_token_t *token, PatternChange *out);
static bool parseSimplePattern(lwjson_t *lwjson, lwjson_token_t *token, SimplePattern *out);
static bool parseEquationSection(lwjson_t *lwjson, lwjson_token_t *token, EquationSection *out);
static bool parseChannelConfig(lwjson_t *lwjson, lwjson_token_t *token, ChannelConfig *out);
static bool parseEquationPattern(lwjson_t *lwjson, lwjson_token_t *token, EquationPattern *out);
static bool parseModePattern(lwjson_t *lwjson, lwjson_token_t *token, ModePattern *out);
static bool parseModeComponent(lwjson_t *lwjson, lwjson_token_t *token, ModeComponent *out);
static bool parseModeAccelTrigger(lwjson_t *lwjson, lwjson_token_t *token, ModeAccelTrigger *out);
static bool parseModeAccel(lwjson_t *lwjson, lwjson_token_t *token, ModeAccel *out);

static bool parsePatternChange(lwjson_t *lwjson, lwjson_token_t *token, PatternChange *out) {
    const lwjson_token_t *t;
    bool valid = true;
    if ((t = lwjson_find_ex(lwjson, token, "ms")) != NULL) {
        out->ms = (uint32_t)t->u.num_int;
        if (out->ms < 0) valid = false;
    } else {
        valid = false;
    }
    if ((t = lwjson_find_ex(lwjson, token, "output")) != NULL) {
        copyString(out->output, t, 7);
    } else {
        valid = false;
    }
    return valid;
}

static bool parseSimplePattern(lwjson_t *lwjson, lwjson_token_t *token, SimplePattern *out) {
    const lwjson_token_t *t;
    bool valid = true;
    out->changeAt_count = 0;
    if ((t = lwjson_find_ex(lwjson, token, "name")) != NULL) {
        copyString(out->name, t, 31);
        if (strlen(out->name) < 1) valid = false;
    } else {
        valid = false;
    }
    if ((t = lwjson_find_ex(lwjson, token, "duration")) != NULL) {
        out->duration = (uint32_t)t->u.num_int;
        if (out->duration < 1) valid = false;
    } else {
        valid = false;
    }
    if ((t = lwjson_find_ex(lwjson, token, "changeAt")) != NULL) {
        const lwjson_token_t *child = lwjson_get_first_child(t);
        while (child != NULL && out->changeAt_count < 64) {
            if (!parsePatternChange(lwjson, (lwjson_token_t*)child, &out->changeAt[out->changeAt_count])) {
                valid = false;
                break;
            }
            out->changeAt_count++;
            child = child->next;
        }
        if (out->changeAt_count < 1) valid = false;
    } else {
        valid = false;
    }
    return valid;
}

static bool parseEquationSection(lwjson_t *lwjson, lwjson_token_t *token, EquationSection *out) {
    const lwjson_token_t *t;
    bool valid = true;
    if ((t = lwjson_find_ex(lwjson, token, "equation")) != NULL) {
        copyString(out->equation, t, 63);
        if (strlen(out->equation) < 1) valid = false;
    } else {
        valid = false;
    }
    if ((t = lwjson_find_ex(lwjson, token, "duration")) != NULL) {
        out->duration = (uint32_t)t->u.num_int;
        if (out->duration < 1) valid = false;
    } else {
        valid = false;
    }
    return valid;
}

static bool parseChannelConfig(lwjson_t *lwjson, lwjson_token_t *token, ChannelConfig *out) {
    const lwjson_token_t *t;
    bool valid = true;
    out->sections_count = 0;
    if ((t = lwjson_find_ex(lwjson, token, "sections")) != NULL) {
        const lwjson_token_t *child = lwjson_get_first_child(t);
        while (child != NULL && out->sections_count < 8) {
            if (!parseEquationSection(lwjson, (lwjson_token_t*)child, &out->sections[out->sections_count])) {
                valid = false;
                break;
            }
            out->sections_count++;
            child = child->next;
        }
    } else {
        valid = false;
    }
    if ((t = lwjson_find_ex(lwjson, token, "loopAfterDuration")) != NULL) {
        out->loopAfterDuration = t->u.num_int != 0; // lwjson parses bools as ints often, or check type
        if (t->type == LWJSON_TYPE_TRUE) out->loopAfterDuration = true;
        else if (t->type == LWJSON_TYPE_FALSE) out->loopAfterDuration = false;
    } else {
        out->loopAfterDuration = true;
    }
    return valid;
}

static bool parseEquationPattern(lwjson_t *lwjson, lwjson_token_t *token, EquationPattern *out) {
    const lwjson_token_t *t;
    bool valid = true;
    out->has_id = false;
    if ((t = lwjson_find_ex(lwjson, token, "id")) != NULL) {
        copyString(out->id, t, 36);
        out->has_id = true;
    }
    if ((t = lwjson_find_ex(lwjson, token, "name")) != NULL) {
        copyString(out->name, t, 31);
        if (strlen(out->name) < 1) valid = false;
    } else {
        valid = false;
    }
    if ((t = lwjson_find_ex(lwjson, token, "duration")) != NULL) {
        out->duration = (uint32_t)t->u.num_int;
        if (out->duration < 0) valid = false;
    } else {
        valid = false;
    }
    if ((t = lwjson_find_ex(lwjson, token, "red")) != NULL) {
        if (!parseChannelConfig(lwjson, (lwjson_token_t*)t, &out->red)) valid = false;
    } else {
        valid = false;
    }
    if ((t = lwjson_find_ex(lwjson, token, "green")) != NULL) {
        if (!parseChannelConfig(lwjson, (lwjson_token_t*)t, &out->green)) valid = false;
    } else {
        valid = false;
    }
    if ((t = lwjson_find_ex(lwjson, token, "blue")) != NULL) {
        if (!parseChannelConfig(lwjson, (lwjson_token_t*)t, &out->blue)) valid = false;
    } else {
        valid = false;
    }
    if (!(out->red.sections_count > 0 || out->green.sections_count > 0 || out->blue.sections_count > 0)) valid = false;
    return valid;
}

static bool parseModePattern(lwjson_t *lwjson, lwjson_token_t *token, ModePattern *out) {
    const lwjson_token_t *t;
    bool valid = true;
    if ((t = lwjson_find_ex(lwjson, token, "type")) != NULL) {
        char typeStr[32];
        copyString(typeStr, t, 31);
        if (strcmp(typeStr, "simple") == 0) {
            out->type = PATTERN_TYPE_SIMPLE;
            if (!parseSimplePattern(lwjson, token, &out->data.simple)) valid = false;
        }
        else if (strcmp(typeStr, "equation") == 0) {
            out->type = PATTERN_TYPE_EQUATION;
            if (!parseEquationPattern(lwjson, token, &out->data.equation)) valid = false;
        }
        else { valid = false; }
    } else { valid = false; }
    return valid;
}

static bool parseModeComponent(lwjson_t *lwjson, lwjson_token_t *token, ModeComponent *out) {
    const lwjson_token_t *t;
    bool valid = true;
    if ((t = lwjson_find_ex(lwjson, token, "pattern")) != NULL) {
        if (!parseModePattern(lwjson, (lwjson_token_t*)t, &out->pattern)) valid = false;
    } else {
        valid = false;
    }
    return valid;
}

static bool parseModeAccelTrigger(lwjson_t *lwjson, lwjson_token_t *token, ModeAccelTrigger *out) {
    const lwjson_token_t *t;
    bool valid = true;
    out->has_front = false;
    out->has_case_comp = false;
    if ((t = lwjson_find_ex(lwjson, token, "threshold")) != NULL) {
        out->threshold = (uint32_t)t->u.num_int;
        if (out->threshold < 0) valid = false;
    } else {
        valid = false;
    }
    if ((t = lwjson_find_ex(lwjson, token, "front")) != NULL) {
        if (!parseModeComponent(lwjson, (lwjson_token_t*)t, &out->front)) valid = false;
        out->has_front = true;
    }
    if ((t = lwjson_find_ex(lwjson, token, "case")) != NULL) {
        if (!parseModeComponent(lwjson, (lwjson_token_t*)t, &out->case_comp)) valid = false;
        out->has_case_comp = true;
    }
    if (!(out->has_front || out->has_case_comp)) valid = false;
    return valid;
}

static bool parseModeAccel(lwjson_t *lwjson, lwjson_token_t *token, ModeAccel *out) {
    const lwjson_token_t *t;
    bool valid = true;
    out->triggers_count = 0;
    if ((t = lwjson_find_ex(lwjson, token, "triggers")) != NULL) {
        const lwjson_token_t *child = lwjson_get_first_child(t);
        while (child != NULL && out->triggers_count < 8) {
            if (!parseModeAccelTrigger(lwjson, (lwjson_token_t*)child, &out->triggers[out->triggers_count])) {
                valid = false;
                break;
            }
            out->triggers_count++;
            child = child->next;
        }
        if (out->triggers_count < 1) valid = false;
    } else {
        valid = false;
    }
    return valid;
}

bool parseMode(lwjson_t *lwjson, lwjson_token_t *token, Mode *out) {
    const lwjson_token_t *t;
    bool valid = true;
    out->has_front = false;
    out->has_case_comp = false;
    out->has_accel = false;
    if ((t = lwjson_find_ex(lwjson, token, "name")) != NULL) {
        copyString(out->name, t, 31);
        if (strlen(out->name) < 1) valid = false;
    } else {
        valid = false;
    }
    if ((t = lwjson_find_ex(lwjson, token, "front")) != NULL) {
        if (!parseModeComponent(lwjson, (lwjson_token_t*)t, &out->front)) valid = false;
        out->has_front = true;
    }
    if ((t = lwjson_find_ex(lwjson, token, "case")) != NULL) {
        if (!parseModeComponent(lwjson, (lwjson_token_t*)t, &out->case_comp)) valid = false;
        out->has_case_comp = true;
    }
    if ((t = lwjson_find_ex(lwjson, token, "accel")) != NULL) {
        if (!parseModeAccel(lwjson, (lwjson_token_t*)t, &out->accel)) valid = false;
        out->has_accel = true;
    }
    if (!(out->has_front || out->has_case_comp)) valid = false;
    return valid;
}

