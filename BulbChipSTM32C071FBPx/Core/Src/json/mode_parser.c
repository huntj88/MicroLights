/* Generated by scripts/generate_c_parser.ts */
#include "json/mode_parser.h"
#include <stdio.h>
#include <string.h>

// Helper to copy string safely
static void copyString(char *dest, const lwjson_token_t *token, size_t maxLen) {
    size_t len = token->u.str.token_value_len;
    if (len > maxLen) {
        len = maxLen;
    }
    memcpy(dest, token->u.str.token_value, len);
    dest[len] = '\0';
}

static void prependContext(ModeErrorContext *ctx, const char *prefix, int32_t index) {
    char tmp[256];
    if (ctx->path[0] == '\0') {
        if (index >= 0) {
            snprintf(tmp, sizeof(tmp), "%s[%d]", prefix, (int)index);
        } else {
            snprintf(tmp, sizeof(tmp), "%s", prefix);
        }
    } else {
        if (index >= 0) {
            snprintf(tmp, sizeof(tmp), "%s[%d].%s", prefix, (int)index, ctx->path);
        } else {
            snprintf(tmp, sizeof(tmp), "%s.%s", prefix, ctx->path);
        }
    }
    strncpy(ctx->path, tmp, sizeof(ctx->path) - 1);
    ctx->path[sizeof(ctx->path) - 1] = '\0';
}

const char *modeParserErrorToString(ModeParserError err) {
    switch (err) {
        case MODE_PARSER_OK:
            return "Success";
        case MODE_PARSER_ERR_MISSING_FIELD:
            return "Missing required field";
        case MODE_PARSER_ERR_STRING_TOO_SHORT:
            return "String is too short";
        case MODE_PARSER_ERR_STRING_TOO_LONG:
            return "String is too long";
        case MODE_PARSER_ERR_VALUE_TOO_SMALL:
            return "Value is too small";
        case MODE_PARSER_ERR_VALUE_TOO_LARGE:
            return "Value is too large";
        case MODE_PARSER_ERR_ARRAY_TOO_SHORT:
            return "Array has too few items";
        case MODE_PARSER_ERR_INVALID_VARIANT:
            return "Invalid variant type";
        case MODE_PARSER_ERR_VALIDATION_FAILED:
            return "Validation failed";
        default:
            return "Unknown error";
    }
}

static uint8_t hexCharToInt(char hexChar) {
    if (hexChar >= '0' && hexChar <= '9') {
        return hexChar - '0';
    }
    if (hexChar >= 'A' && hexChar <= 'F') {
        return hexChar - 'A' + 10;
    }
    if (hexChar >= 'a' && hexChar <= 'f') {
        return hexChar - 'a' + 10;
    }
    return 0;
}

static bool parseSimpleOutput(
    lwjson_t *lwjson, lwjson_token_t *token, SimpleOutput *out, ModeErrorContext *ctx) {
    if (token->type != LWJSON_TYPE_STRING) {
        ctx->error = MODE_PARSER_ERR_VALIDATION_FAILED;
        return false;
    }

    char tmp[16];
    copyString(tmp, token, 15);

    if (strcmp(tmp, "high") == 0) {
        out->type = BULB;
        out->data.bulb = high;
        return true;
    }
    if (strcmp(tmp, "low") == 0) {
        out->type = BULB;
        out->data.bulb = low;
        return true;
    }

    if (tmp[0] == '#' && strlen(tmp) == 7) {
        out->type = RGB;
        out->data.rgb.r = (hexCharToInt(tmp[1]) << 4) | hexCharToInt(tmp[2]);
        out->data.rgb.g = (hexCharToInt(tmp[3]) << 4) | hexCharToInt(tmp[4]);
        out->data.rgb.b = (hexCharToInt(tmp[5]) << 4) | hexCharToInt(tmp[6]);
        return true;
    }

    ctx->error = MODE_PARSER_ERR_VALIDATION_FAILED;
    return false;
}

// NOLINTBEGIN(bugprone-easily-swappable-parameters)
static bool parseStringField(
    const lwjson_token_t *token,
    char *out,
    size_t min,
    size_t max,
    ModeErrorContext *ctx,
    const char *fieldName) {
    if (token->u.str.token_value_len > max) {
        ctx->error = MODE_PARSER_ERR_STRING_TOO_LONG;
        strcpy(ctx->path, fieldName);
        return false;
    }
    copyString(out, token, max);
    if (strlen(out) < min) {
        ctx->error = MODE_PARSER_ERR_STRING_TOO_SHORT;
        strcpy(ctx->path, fieldName);
        return false;
    }
    return true;
}

static bool parseUInt32Field(
    const lwjson_token_t *token,
    uint32_t *out,
    uint32_t min,
    uint32_t max,
    ModeErrorContext *ctx,
    const char *fieldName) {
    if (token->u.num_int < (lwjson_int_t)min) {
        ctx->error = MODE_PARSER_ERR_VALUE_TOO_SMALL;
        strcpy(ctx->path, fieldName);
        return false;
    }
    if (token->u.num_int > (lwjson_int_t)max) {
        ctx->error = MODE_PARSER_ERR_VALUE_TOO_LARGE;
        strcpy(ctx->path, fieldName);
        return false;
    }
    *out = (uint32_t)token->u.num_int;
    return true;
}

static bool parseUInt8Field(
    const lwjson_token_t *token,
    uint8_t *out,
    uint8_t min,
    uint8_t max,
    ModeErrorContext *ctx,
    const char *fieldName) {
    if (token->u.num_int < (lwjson_int_t)min) {
        ctx->error = MODE_PARSER_ERR_VALUE_TOO_SMALL;
        strcpy(ctx->path, fieldName);
        return false;
    }
    if (token->u.num_int > (lwjson_int_t)max) {
        ctx->error = MODE_PARSER_ERR_VALUE_TOO_LARGE;
        strcpy(ctx->path, fieldName);
        return false;
    }
    *out = (uint8_t)token->u.num_int;
    return true;
}
// NOLINTEND(bugprone-easily-swappable-parameters)

static bool parseBooleanField(const lwjson_token_t *token, bool *out) {
    if (token->type == LWJSON_TYPE_TRUE) {
        *out = true;
    } else if (token->type == LWJSON_TYPE_FALSE) {
        *out = false;
    } else {
        *out = token->u.num_int != 0;
    }
    return true;
}

static bool parsePatternChange(
    lwjson_t *lwjson, lwjson_token_t *token, PatternChange *out, ModeErrorContext *ctx);
static bool parseSimplePattern(
    lwjson_t *lwjson, lwjson_token_t *token, SimplePattern *out, ModeErrorContext *ctx);
static bool parseEquationSection(
    lwjson_t *lwjson, lwjson_token_t *token, EquationSection *out, ModeErrorContext *ctx);
static bool parseChannelConfig(
    lwjson_t *lwjson, lwjson_token_t *token, ChannelConfig *out, ModeErrorContext *ctx);
static bool parseEquationPattern(
    lwjson_t *lwjson, lwjson_token_t *token, EquationPattern *out, ModeErrorContext *ctx);
static bool parseModePattern(
    lwjson_t *lwjson, lwjson_token_t *token, ModePattern *out, ModeErrorContext *ctx);
static bool parseModeComponent(
    lwjson_t *lwjson, lwjson_token_t *token, ModeComponent *out, ModeErrorContext *ctx);
static bool parseModeAccelTrigger(
    lwjson_t *lwjson, lwjson_token_t *token, ModeAccelTrigger *out, ModeErrorContext *ctx);
static bool parseModeAccel(
    lwjson_t *lwjson, lwjson_token_t *token, ModeAccel *out, ModeErrorContext *ctx);

static bool parsePatternChange(
    lwjson_t *lwjson, lwjson_token_t *token, PatternChange *out, ModeErrorContext *ctx) {
    const lwjson_token_t *tokenField;
    tokenField = lwjson_find_ex(lwjson, token, "ms");
    if (tokenField != NULL) {
        if (!parseUInt32Field(tokenField, &out->ms, 0, 4294967295U, ctx, "ms")) {
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "ms");
        return false;
    }
    tokenField = lwjson_find_ex(lwjson, token, "output");
    if (tokenField != NULL) {
        if (!parseSimpleOutput(lwjson, (lwjson_token_t *)tokenField, &out->output, ctx)) {
            prependContext(ctx, "output", -1);
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "output");
        return false;
    }
    return true;
}

static bool parseSimplePattern(
    lwjson_t *lwjson, lwjson_token_t *token, SimplePattern *out, ModeErrorContext *ctx) {
    const lwjson_token_t *tokenField;
    out->changeAtCount = 0;
    tokenField = lwjson_find_ex(lwjson, token, "name");
    if (tokenField != NULL) {
        if (!parseStringField(tokenField, out->name, 1, 31, ctx, "name")) {
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "name");
        return false;
    }
    tokenField = lwjson_find_ex(lwjson, token, "duration");
    if (tokenField != NULL) {
        if (!parseUInt32Field(tokenField, &out->duration, 1, 4294967295U, ctx, "duration")) {
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "duration");
        return false;
    }
    tokenField = lwjson_find_ex(lwjson, token, "changeAt");
    if (tokenField != NULL) {
        const lwjson_token_t *child = lwjson_get_first_child(tokenField);
        while (child != NULL && out->changeAtCount < 32) {
            if (!parsePatternChange(
                    lwjson, (lwjson_token_t *)child, &out->changeAt[out->changeAtCount], ctx)) {
                prependContext(ctx, "changeAt", out->changeAtCount);
                return false;
            }
            out->changeAtCount++;
            child = child->next;
        }
        if (out->changeAtCount < 1) {
            ctx->error = MODE_PARSER_ERR_ARRAY_TOO_SHORT;
            strcpy(ctx->path, "changeAt");
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "changeAt");
        return false;
    }
    return true;
}

static bool parseEquationSection(
    lwjson_t *lwjson, lwjson_token_t *token, EquationSection *out, ModeErrorContext *ctx) {
    const lwjson_token_t *tokenField;
    tokenField = lwjson_find_ex(lwjson, token, "equation");
    if (tokenField != NULL) {
        if (!parseStringField(tokenField, out->equation, 1, 63, ctx, "equation")) {
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "equation");
        return false;
    }
    tokenField = lwjson_find_ex(lwjson, token, "duration");
    if (tokenField != NULL) {
        if (!parseUInt32Field(tokenField, &out->duration, 1, 4294967295U, ctx, "duration")) {
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "duration");
        return false;
    }
    return true;
}

static bool parseChannelConfig(
    lwjson_t *lwjson, lwjson_token_t *token, ChannelConfig *out, ModeErrorContext *ctx) {
    const lwjson_token_t *tokenField;
    out->sectionsCount = 0;
    tokenField = lwjson_find_ex(lwjson, token, "sections");
    if (tokenField != NULL) {
        const lwjson_token_t *child = lwjson_get_first_child(tokenField);
        while (child != NULL && out->sectionsCount < 3) {
            if (!parseEquationSection(
                    lwjson, (lwjson_token_t *)child, &out->sections[out->sectionsCount], ctx)) {
                prependContext(ctx, "sections", out->sectionsCount);
                return false;
            }
            out->sectionsCount++;
            child = child->next;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "sections");
        return false;
    }
    tokenField = lwjson_find_ex(lwjson, token, "loopAfterDuration");
    if (tokenField != NULL) {
        parseBooleanField(tokenField, &out->loopAfterDuration);
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "loopAfterDuration");
        return false;
    }
    return true;
}

static bool parseEquationPattern(
    lwjson_t *lwjson, lwjson_token_t *token, EquationPattern *out, ModeErrorContext *ctx) {
    const lwjson_token_t *tokenField;
    tokenField = lwjson_find_ex(lwjson, token, "name");
    if (tokenField != NULL) {
        if (!parseStringField(tokenField, out->name, 1, 31, ctx, "name")) {
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "name");
        return false;
    }
    tokenField = lwjson_find_ex(lwjson, token, "duration");
    if (tokenField != NULL) {
        if (!parseUInt32Field(tokenField, &out->duration, 0, 4294967295U, ctx, "duration")) {
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "duration");
        return false;
    }
    tokenField = lwjson_find_ex(lwjson, token, "red");
    if (tokenField != NULL) {
        if (!parseChannelConfig(lwjson, (lwjson_token_t *)tokenField, &out->red, ctx)) {
            prependContext(ctx, "red", -1);
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "red");
        return false;
    }
    tokenField = lwjson_find_ex(lwjson, token, "green");
    if (tokenField != NULL) {
        if (!parseChannelConfig(lwjson, (lwjson_token_t *)tokenField, &out->green, ctx)) {
            prependContext(ctx, "green", -1);
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "green");
        return false;
    }
    tokenField = lwjson_find_ex(lwjson, token, "blue");
    if (tokenField != NULL) {
        if (!parseChannelConfig(lwjson, (lwjson_token_t *)tokenField, &out->blue, ctx)) {
            prependContext(ctx, "blue", -1);
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "blue");
        return false;
    }
    if (!(out->red.sectionsCount > 0 || out->green.sectionsCount > 0 ||
          out->blue.sectionsCount > 0)) {
        ctx->error = MODE_PARSER_ERR_VALIDATION_FAILED;
        strcpy(ctx->path, "red");
        return false;
    }
    return true;
}

static bool parseModePattern(
    lwjson_t *lwjson, lwjson_token_t *token, ModePattern *out, ModeErrorContext *ctx) {
    const lwjson_token_t *tokenField;
    tokenField = lwjson_find_ex(lwjson, token, "type");
    if (tokenField != NULL) {
        char typeStr[32];
        if (!parseStringField(tokenField, typeStr, 1, 31, ctx, "type")) {
            return false;
        }
        if (strcmp(typeStr, "simple") == 0) {
            out->type = PATTERN_TYPE_SIMPLE;
            if (!parseSimplePattern(lwjson, token, &out->data.simple, ctx)) {
                return false;
            }
        } else if (strcmp(typeStr, "equation") == 0) {
            out->type = PATTERN_TYPE_EQUATION;
            if (!parseEquationPattern(lwjson, token, &out->data.equation, ctx)) {
                return false;
            }
        } else {
            ctx->error = MODE_PARSER_ERR_INVALID_VARIANT;
            strcpy(ctx->path, "type");
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "type");
        return false;
    }
    return true;
}

static bool parseModeComponent(
    lwjson_t *lwjson, lwjson_token_t *token, ModeComponent *out, ModeErrorContext *ctx) {
    const lwjson_token_t *tokenField;
    tokenField = lwjson_find_ex(lwjson, token, "pattern");
    if (tokenField != NULL) {
        if (!parseModePattern(lwjson, (lwjson_token_t *)tokenField, &out->pattern, ctx)) {
            prependContext(ctx, "pattern", -1);
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "pattern");
        return false;
    }
    return true;
}

static bool parseModeAccelTrigger(
    lwjson_t *lwjson, lwjson_token_t *token, ModeAccelTrigger *out, ModeErrorContext *ctx) {
    const lwjson_token_t *tokenField;
    out->hasFront = false;
    out->hasCaseComp = false;
    tokenField = lwjson_find_ex(lwjson, token, "threshold");
    if (tokenField != NULL) {
        if (!parseUInt8Field(tokenField, &out->threshold, 0, 255, ctx, "threshold")) {
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "threshold");
        return false;
    }
    tokenField = lwjson_find_ex(lwjson, token, "front");
    if (tokenField != NULL) {
        if (!parseModeComponent(lwjson, (lwjson_token_t *)tokenField, &out->front, ctx)) {
            prependContext(ctx, "front", -1);
            return false;
        }
        out->hasFront = true;
    }
    tokenField = lwjson_find_ex(lwjson, token, "case");
    if (tokenField != NULL) {
        if (!parseModeComponent(lwjson, (lwjson_token_t *)tokenField, &out->caseComp, ctx)) {
            prependContext(ctx, "case", -1);
            return false;
        }
        out->hasCaseComp = true;
    }
    if (!(out->hasFront || out->hasCaseComp)) {
        ctx->error = MODE_PARSER_ERR_VALIDATION_FAILED;
        strcpy(ctx->path, "front");
        return false;
    }
    return true;
}

static bool parseModeAccel(
    lwjson_t *lwjson, lwjson_token_t *token, ModeAccel *out, ModeErrorContext *ctx) {
    const lwjson_token_t *tokenField;
    out->triggersCount = 0;
    tokenField = lwjson_find_ex(lwjson, token, "triggers");
    if (tokenField != NULL) {
        const lwjson_token_t *child = lwjson_get_first_child(tokenField);
        while (child != NULL && out->triggersCount < 2) {
            if (!parseModeAccelTrigger(
                    lwjson, (lwjson_token_t *)child, &out->triggers[out->triggersCount], ctx)) {
                prependContext(ctx, "triggers", out->triggersCount);
                return false;
            }
            out->triggersCount++;
            child = child->next;
        }
        if (out->triggersCount < 1) {
            ctx->error = MODE_PARSER_ERR_ARRAY_TOO_SHORT;
            strcpy(ctx->path, "triggers");
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "triggers");
        return false;
    }
    return true;
}

bool parseMode(lwjson_t *lwjson, lwjson_token_t *token, Mode *out, ModeErrorContext *ctx) {
    const lwjson_token_t *tokenField;
    out->hasFront = false;
    out->hasCaseComp = false;
    out->hasAccel = false;
    tokenField = lwjson_find_ex(lwjson, token, "name");
    if (tokenField != NULL) {
        if (!parseStringField(tokenField, out->name, 1, 31, ctx, "name")) {
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "name");
        return false;
    }
    tokenField = lwjson_find_ex(lwjson, token, "front");
    if (tokenField != NULL) {
        if (!parseModeComponent(lwjson, (lwjson_token_t *)tokenField, &out->front, ctx)) {
            prependContext(ctx, "front", -1);
            return false;
        }
        out->hasFront = true;
    }
    tokenField = lwjson_find_ex(lwjson, token, "case");
    if (tokenField != NULL) {
        if (!parseModeComponent(lwjson, (lwjson_token_t *)tokenField, &out->caseComp, ctx)) {
            prependContext(ctx, "case", -1);
            return false;
        }
        out->hasCaseComp = true;
    }
    tokenField = lwjson_find_ex(lwjson, token, "accel");
    if (tokenField != NULL) {
        if (!parseModeAccel(lwjson, (lwjson_token_t *)tokenField, &out->accel, ctx)) {
            prependContext(ctx, "accel", -1);
            return false;
        }
        out->hasAccel = true;
    }
    if (!(out->hasFront || out->hasCaseComp)) {
        ctx->error = MODE_PARSER_ERR_VALIDATION_FAILED;
        strcpy(ctx->path, "front");
        return false;
    }
    return true;
}
