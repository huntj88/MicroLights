/* Generated by scripts/generate_c_parser.ts */
#include <string.h>
#include <stdio.h>
#include "json/mode_parser.h"

// Helper to copy string safely
static void copyString(char *dest, const lwjson_token_t *token, size_t maxLen) {
    size_t len = token->u.str.token_value_len;
    if (len > maxLen) len = maxLen;
    memcpy(dest, token->u.str.token_value, len);
    dest[len] = '\0';
}

static void prependContext(ModeErrorContext *ctx, const char *prefix, int32_t index) {
    char tmp[256];
    if (ctx->path[0] == '\0') {
        if (index >= 0) snprintf(tmp, sizeof(tmp), "%s[%d]", prefix, (int)index);
        else snprintf(tmp, sizeof(tmp), "%s", prefix);
    } else {
        if (index >= 0) snprintf(tmp, sizeof(tmp), "%s[%d].%s", prefix, (int)index, ctx->path);
        else snprintf(tmp, sizeof(tmp), "%s.%s", prefix, ctx->path);
    }
    strncpy(ctx->path, tmp, sizeof(ctx->path) - 1);
    ctx->path[sizeof(ctx->path) - 1] = '\0';
}

const char* modeParserErrorToString(ModeParserError err) {
    switch (err) {
        case MODE_PARSER_OK: return "Success";
        case MODE_PARSER_ERR_MISSING_FIELD: return "Missing required field";
        case MODE_PARSER_ERR_STRING_TOO_SHORT: return "String is too short";
        case MODE_PARSER_ERR_VALUE_TOO_SMALL: return "Value is too small";
        case MODE_PARSER_ERR_VALUE_TOO_LARGE: return "Value is too large";
        case MODE_PARSER_ERR_ARRAY_TOO_SHORT: return "Array has too few items";
        case MODE_PARSER_ERR_INVALID_VARIANT: return "Invalid variant type";
        case MODE_PARSER_ERR_VALIDATION_FAILED: return "Validation failed";
        default: return "Unknown error";
    }
}

static uint8_t hexCharToInt(char c) {
    if (c >= '0' && c <= '9') return c - '0';
    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
    return 0;
}

static bool parseSimpleOutput(lwjson_t *lwjson, lwjson_token_t *token, SimpleOutput *out, ModeErrorContext *ctx) {
    if (token->type != LWJSON_TYPE_STRING) {
        ctx->error = MODE_PARSER_ERR_VALIDATION_FAILED;
        return false;
    }
    
    char tmp[16];
    copyString(tmp, token, 15);
    
    if (strcmp(tmp, "high") == 0) {
        out->type = BULB;
        out->data.bulb = high;
        return true;
    }
    if (strcmp(tmp, "low") == 0) {
        out->type = BULB;
        out->data.bulb = low;
        return true;
    }
    
    if (tmp[0] == '#' && strlen(tmp) == 7) {
        out->type = RGB;
        out->data.rgb.r = (hexCharToInt(tmp[1]) << 4) | hexCharToInt(tmp[2]);
        out->data.rgb.g = (hexCharToInt(tmp[3]) << 4) | hexCharToInt(tmp[4]);
        out->data.rgb.b = (hexCharToInt(tmp[5]) << 4) | hexCharToInt(tmp[6]);
        return true;
    }
    
    ctx->error = MODE_PARSER_ERR_VALIDATION_FAILED;
    return false;
}

static bool parseSimpleOutput(lwjson_t *lwjson, lwjson_token_t *token, SimpleOutput *out, ModeErrorContext *ctx);
static bool parsePatternChange(lwjson_t *lwjson, lwjson_token_t *token, PatternChange *out, ModeErrorContext *ctx);
static bool parseSimplePattern(lwjson_t *lwjson, lwjson_token_t *token, SimplePattern *out, ModeErrorContext *ctx);
static bool parseEquationSection(lwjson_t *lwjson, lwjson_token_t *token, EquationSection *out, ModeErrorContext *ctx);
static bool parseChannelConfig(lwjson_t *lwjson, lwjson_token_t *token, ChannelConfig *out, ModeErrorContext *ctx);
static bool parseEquationPattern(lwjson_t *lwjson, lwjson_token_t *token, EquationPattern *out, ModeErrorContext *ctx);
static bool parseModePattern(lwjson_t *lwjson, lwjson_token_t *token, ModePattern *out, ModeErrorContext *ctx);
static bool parseModeComponent(lwjson_t *lwjson, lwjson_token_t *token, ModeComponent *out, ModeErrorContext *ctx);
static bool parseModeAccelTrigger(lwjson_t *lwjson, lwjson_token_t *token, ModeAccelTrigger *out, ModeErrorContext *ctx);
static bool parseModeAccel(lwjson_t *lwjson, lwjson_token_t *token, ModeAccel *out, ModeErrorContext *ctx);

static bool parsePatternChange(lwjson_t *lwjson, lwjson_token_t *token, PatternChange *out, ModeErrorContext *ctx) {
    const lwjson_token_t *t;
    if ((t = lwjson_find_ex(lwjson, token, "ms")) != NULL) {
        if (t->u.num_int < 0) {
            ctx->error = MODE_PARSER_ERR_VALUE_TOO_SMALL;
            strcpy(ctx->path, "ms");
            return false;
        }
        if (t->u.num_int > 4294967295) {
            ctx->error = MODE_PARSER_ERR_VALUE_TOO_LARGE;
            strcpy(ctx->path, "ms");
            return false;
        }
        out->ms = (uint32_t)t->u.num_int;
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "ms");
        return false;
    }
    if ((t = lwjson_find_ex(lwjson, token, "output")) != NULL) {
        if (!parseSimpleOutput(lwjson, (lwjson_token_t*)t, &out->output, ctx)) {
            prependContext(ctx, "output", -1);
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "output");
        return false;
    }
    return true;
}

static bool parseSimplePattern(lwjson_t *lwjson, lwjson_token_t *token, SimplePattern *out, ModeErrorContext *ctx) {
    const lwjson_token_t *t;
    out->changeAt_count = 0;
    if ((t = lwjson_find_ex(lwjson, token, "name")) != NULL) {
        copyString(out->name, t, 31);
        if (strlen(out->name) < 1) {
            ctx->error = MODE_PARSER_ERR_STRING_TOO_SHORT;
            strcpy(ctx->path, "name");
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "name");
        return false;
    }
    if ((t = lwjson_find_ex(lwjson, token, "duration")) != NULL) {
        if (t->u.num_int < 1) {
            ctx->error = MODE_PARSER_ERR_VALUE_TOO_SMALL;
            strcpy(ctx->path, "duration");
            return false;
        }
        if (t->u.num_int > 4294967295) {
            ctx->error = MODE_PARSER_ERR_VALUE_TOO_LARGE;
            strcpy(ctx->path, "duration");
            return false;
        }
        out->duration = (uint32_t)t->u.num_int;
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "duration");
        return false;
    }
    if ((t = lwjson_find_ex(lwjson, token, "changeAt")) != NULL) {
        const lwjson_token_t *child = lwjson_get_first_child(t);
        while (child != NULL && out->changeAt_count < 32) {
            if (!parsePatternChange(lwjson, (lwjson_token_t*)child, &out->changeAt[out->changeAt_count], ctx)) {
                prependContext(ctx, "changeAt", out->changeAt_count);
                return false;
            }
            out->changeAt_count++;
            child = child->next;
        }
        if (out->changeAt_count < 1) {
            ctx->error = MODE_PARSER_ERR_ARRAY_TOO_SHORT;
            strcpy(ctx->path, "changeAt");
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "changeAt");
        return false;
    }
    return true;
}

static bool parseEquationSection(lwjson_t *lwjson, lwjson_token_t *token, EquationSection *out, ModeErrorContext *ctx) {
    const lwjson_token_t *t;
    if ((t = lwjson_find_ex(lwjson, token, "equation")) != NULL) {
        copyString(out->equation, t, 63);
        if (strlen(out->equation) < 1) {
            ctx->error = MODE_PARSER_ERR_STRING_TOO_SHORT;
            strcpy(ctx->path, "equation");
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "equation");
        return false;
    }
    if ((t = lwjson_find_ex(lwjson, token, "duration")) != NULL) {
        if (t->u.num_int < 1) {
            ctx->error = MODE_PARSER_ERR_VALUE_TOO_SMALL;
            strcpy(ctx->path, "duration");
            return false;
        }
        if (t->u.num_int > 4294967295) {
            ctx->error = MODE_PARSER_ERR_VALUE_TOO_LARGE;
            strcpy(ctx->path, "duration");
            return false;
        }
        out->duration = (uint32_t)t->u.num_int;
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "duration");
        return false;
    }
    return true;
}

static bool parseChannelConfig(lwjson_t *lwjson, lwjson_token_t *token, ChannelConfig *out, ModeErrorContext *ctx) {
    const lwjson_token_t *t;
    out->sections_count = 0;
    if ((t = lwjson_find_ex(lwjson, token, "sections")) != NULL) {
        const lwjson_token_t *child = lwjson_get_first_child(t);
        while (child != NULL && out->sections_count < 3) {
            if (!parseEquationSection(lwjson, (lwjson_token_t*)child, &out->sections[out->sections_count], ctx)) {
                prependContext(ctx, "sections", out->sections_count);
                return false;
            }
            out->sections_count++;
            child = child->next;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "sections");
        return false;
    }
    if ((t = lwjson_find_ex(lwjson, token, "loopAfterDuration")) != NULL) {
        out->loopAfterDuration = t->u.num_int != 0; // lwjson parses bools as ints often, or check type
        if (t->type == LWJSON_TYPE_TRUE) out->loopAfterDuration = true;
        else if (t->type == LWJSON_TYPE_FALSE) out->loopAfterDuration = false;
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "loopAfterDuration");
        return false;
    }
    return true;
}

static bool parseEquationPattern(lwjson_t *lwjson, lwjson_token_t *token, EquationPattern *out, ModeErrorContext *ctx) {
    const lwjson_token_t *t;
    if ((t = lwjson_find_ex(lwjson, token, "name")) != NULL) {
        copyString(out->name, t, 31);
        if (strlen(out->name) < 1) {
            ctx->error = MODE_PARSER_ERR_STRING_TOO_SHORT;
            strcpy(ctx->path, "name");
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "name");
        return false;
    }
    if ((t = lwjson_find_ex(lwjson, token, "duration")) != NULL) {
        if (t->u.num_int < 0) {
            ctx->error = MODE_PARSER_ERR_VALUE_TOO_SMALL;
            strcpy(ctx->path, "duration");
            return false;
        }
        if (t->u.num_int > 4294967295) {
            ctx->error = MODE_PARSER_ERR_VALUE_TOO_LARGE;
            strcpy(ctx->path, "duration");
            return false;
        }
        out->duration = (uint32_t)t->u.num_int;
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "duration");
        return false;
    }
    if ((t = lwjson_find_ex(lwjson, token, "red")) != NULL) {
        if (!parseChannelConfig(lwjson, (lwjson_token_t*)t, &out->red, ctx)) {
            prependContext(ctx, "red", -1);
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "red");
        return false;
    }
    if ((t = lwjson_find_ex(lwjson, token, "green")) != NULL) {
        if (!parseChannelConfig(lwjson, (lwjson_token_t*)t, &out->green, ctx)) {
            prependContext(ctx, "green", -1);
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "green");
        return false;
    }
    if ((t = lwjson_find_ex(lwjson, token, "blue")) != NULL) {
        if (!parseChannelConfig(lwjson, (lwjson_token_t*)t, &out->blue, ctx)) {
            prependContext(ctx, "blue", -1);
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "blue");
        return false;
    }
    if (!(out->red.sections_count > 0 || out->green.sections_count > 0 || out->blue.sections_count > 0)) {
        ctx->error = MODE_PARSER_ERR_VALIDATION_FAILED;
        strcpy(ctx->path, "red");
        return false;
    }
    return true;
}

static bool parseModePattern(lwjson_t *lwjson, lwjson_token_t *token, ModePattern *out, ModeErrorContext *ctx) {
    const lwjson_token_t *t;
    if ((t = lwjson_find_ex(lwjson, token, "type")) != NULL) {
        char typeStr[32];
        copyString(typeStr, t, 31);
        if (strcmp(typeStr, "simple") == 0) {
            out->type = PATTERN_TYPE_SIMPLE;
            if (!parseSimplePattern(lwjson, token, &out->data.simple, ctx)) return false;
        }
        else if (strcmp(typeStr, "equation") == 0) {
            out->type = PATTERN_TYPE_EQUATION;
            if (!parseEquationPattern(lwjson, token, &out->data.equation, ctx)) return false;
        }
        else {
            ctx->error = MODE_PARSER_ERR_INVALID_VARIANT;
            strcpy(ctx->path, "type");
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "type");
        return false;
    }
    return true;
}

static bool parseModeComponent(lwjson_t *lwjson, lwjson_token_t *token, ModeComponent *out, ModeErrorContext *ctx) {
    const lwjson_token_t *t;
    if ((t = lwjson_find_ex(lwjson, token, "pattern")) != NULL) {
        if (!parseModePattern(lwjson, (lwjson_token_t*)t, &out->pattern, ctx)) {
            prependContext(ctx, "pattern", -1);
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "pattern");
        return false;
    }
    return true;
}

static bool parseModeAccelTrigger(lwjson_t *lwjson, lwjson_token_t *token, ModeAccelTrigger *out, ModeErrorContext *ctx) {
    const lwjson_token_t *t;
    out->has_front = false;
    out->has_case_comp = false;
    if ((t = lwjson_find_ex(lwjson, token, "threshold")) != NULL) {
        if (t->u.num_int < 0) {
            ctx->error = MODE_PARSER_ERR_VALUE_TOO_SMALL;
            strcpy(ctx->path, "threshold");
            return false;
        }
        if (t->u.num_int > 255) {
            ctx->error = MODE_PARSER_ERR_VALUE_TOO_LARGE;
            strcpy(ctx->path, "threshold");
            return false;
        }
        out->threshold = (uint8_t)t->u.num_int;
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "threshold");
        return false;
    }
    if ((t = lwjson_find_ex(lwjson, token, "front")) != NULL) {
        if (!parseModeComponent(lwjson, (lwjson_token_t*)t, &out->front, ctx)) {
            prependContext(ctx, "front", -1);
            return false;
        }
        out->has_front = true;
    }
    if ((t = lwjson_find_ex(lwjson, token, "case")) != NULL) {
        if (!parseModeComponent(lwjson, (lwjson_token_t*)t, &out->case_comp, ctx)) {
            prependContext(ctx, "case", -1);
            return false;
        }
        out->has_case_comp = true;
    }
    if (!(out->has_front || out->has_case_comp)) {
        ctx->error = MODE_PARSER_ERR_VALIDATION_FAILED;
        strcpy(ctx->path, "front");
        return false;
    }
    return true;
}

static bool parseModeAccel(lwjson_t *lwjson, lwjson_token_t *token, ModeAccel *out, ModeErrorContext *ctx) {
    const lwjson_token_t *t;
    out->triggers_count = 0;
    if ((t = lwjson_find_ex(lwjson, token, "triggers")) != NULL) {
        const lwjson_token_t *child = lwjson_get_first_child(t);
        while (child != NULL && out->triggers_count < 2) {
            if (!parseModeAccelTrigger(lwjson, (lwjson_token_t*)child, &out->triggers[out->triggers_count], ctx)) {
                prependContext(ctx, "triggers", out->triggers_count);
                return false;
            }
            out->triggers_count++;
            child = child->next;
        }
        if (out->triggers_count < 1) {
            ctx->error = MODE_PARSER_ERR_ARRAY_TOO_SHORT;
            strcpy(ctx->path, "triggers");
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "triggers");
        return false;
    }
    return true;
}

bool parseMode(lwjson_t *lwjson, lwjson_token_t *token, Mode *out, ModeErrorContext *ctx) {
    const lwjson_token_t *t;
    out->has_front = false;
    out->has_case_comp = false;
    out->has_accel = false;
    if ((t = lwjson_find_ex(lwjson, token, "name")) != NULL) {
        copyString(out->name, t, 31);
        if (strlen(out->name) < 1) {
            ctx->error = MODE_PARSER_ERR_STRING_TOO_SHORT;
            strcpy(ctx->path, "name");
            return false;
        }
    } else {
        ctx->error = MODE_PARSER_ERR_MISSING_FIELD;
        strcpy(ctx->path, "name");
        return false;
    }
    if ((t = lwjson_find_ex(lwjson, token, "front")) != NULL) {
        if (!parseModeComponent(lwjson, (lwjson_token_t*)t, &out->front, ctx)) {
            prependContext(ctx, "front", -1);
            return false;
        }
        out->has_front = true;
    }
    if ((t = lwjson_find_ex(lwjson, token, "case")) != NULL) {
        if (!parseModeComponent(lwjson, (lwjson_token_t*)t, &out->case_comp, ctx)) {
            prependContext(ctx, "case", -1);
            return false;
        }
        out->has_case_comp = true;
    }
    if ((t = lwjson_find_ex(lwjson, token, "accel")) != NULL) {
        if (!parseModeAccel(lwjson, (lwjson_token_t*)t, &out->accel, ctx)) {
            prependContext(ctx, "accel", -1);
            return false;
        }
        out->has_accel = true;
    }
    if (!(out->has_front || out->has_case_comp)) {
        ctx->error = MODE_PARSER_ERR_VALIDATION_FAILED;
        strcpy(ctx->path, "front");
        return false;
    }
    return true;
}

